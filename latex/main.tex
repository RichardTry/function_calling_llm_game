\documentclass[14pt]{extarticle}
\usepackage[left=3.5cm, right=1.5cm, vmargin=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\linespread{1.3}
\usepackage{siunitx}

\usepackage{caption}
\usepackage{subcaption}
\renewcommand\thesubfigure{\asbuk{subfigure}}


\usepackage{enumitem}

\usepackage{float}
\usepackage{cases}
\usepackage{csquotes}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}   %% загружает пакет многоязыковой вёрстки
\usepackage{graphicx}% Include figure files
\usepackage{dcolumn}% Align table columns on decimal point
\usepackage{bm}% bold math
\usepackage{hyperref}% add hypertext capabilities
\usepackage{xcolor}
\usepackage[mathlines]{lineno}% Enable numbering of text and display math
%\linenumbers\relax % Commence numbering lines

\bibliographystyle{IEEEtran} 
\setlength{\emergencystretch}{30pt}
\usepackage{hyphenat}
\hyphenation{ма-те-ма-ти-ка вос-ста-нав-ли-вать}

\definecolor{linkcolor}{HTML}{0000D5} % цвет ссылок
\definecolor{urlcolor}{HTML}{0000D5} % цвет гиперссылок
\definecolor{citecolor}{HTML}{0000D5}

 
\hypersetup{pdfstartview=FitH,  linkcolor=linkcolor,urlcolor=urlcolor, colorlinks=true}
 
%\usepackage[showframe,%Uncomment any one of the following lines to test 
%%scale=0.7, marginratio={1:1, 2:3}, ignoreall,% default settings
%%text={7in,10in},centering,
%%margin=1.5in,
%%total={6.5in,8.75in}, top=1.2in, left=0.9in, includefoot,
%%height=10in,a5paper,hmargin={3cm,0.8in},
%]{geometry}

\usepackage{etoolbox}
\makeatletter
% \frontmatter@RRAP@format is responsible for the parentheses
\patchcmd{\frontmatter@RRAP@format}{(}{}{}{}
\patchcmd{\frontmatter@RRAP@format}{)}{}{}{}

\makeatother

\begin{document}
	\begin{titlepage}
        \newgeometry{left=1.5cm, right=1.5cm, vmargin=2cm}
		\begin{center}
			{\normalsize{ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ АВТОНОМНОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ}}\\
                \vspace{0.1cm}
			{\normalsize{«НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ УНИВЕРСИТЕТ \\ “ВЫСШАЯ ШКОЛА ЭКОНОМИКИ”»}}\\
			\vspace{1cm}
			{\normalsize{Факультет Компьютерных Наук}}\\
                \vspace{1.5cm}
                

                {\normalsize{Базров Степан Артурович}}\\
                \vspace{0.15cm}
			{\normalsize{\textbf{Создание игры при помощи LLM с Function Calling}}}\\ 
                \vspace{0.15cm}
                {\normalsize{Выпускная квалификационная работа}}\\
                {\normalsize{по направлению подготовки 01.04.02 Прикладная математика и информатика}}\\
                {\normalsize{образовательная программа «Машинное обучение и высоконагруженные системы»}} \\
            \end{center}
        \vspace{4.2cm}
        \begin{minipage}{0.4\textwidth}
        \hfill
	\end{minipage}
	\hspace{2cm}
	\begin{minipage}{0.4\textwidth}
		\begin{flushleft}
			{\normalsize{{Научный руководитель}}}\\
                {\normalsize{разработчик в «Яндекс»}}\\
                {\normalsize{Беляев Артём Русланович}} \\
		\end{flushleft}
	\end{minipage}
            \vspace{4.0cm}
        \begin{center}
            Москва 2025
        \end{center}
        \restoregeometry
	\end{titlepage}
\tableofcontents
\newpage
\section*{Аннотация}
С развитием больших языковых моделей (LLM) разработчики компьютерных игр начали активно экспериментировать с их интеграцией в игровой процесс. Одним из первых и наиболее известных примеров стал AI Dungeon, в котором LLM используется почти напрямую в виде текстового чата с игроком. Такой подход привел к тому, что вместо сюжетной игры с четкой игровой логикой, пользователи зачастую получают бесконечный текстовый диалог, не ограниченный темой или контекстом.

Для преодоления данных ограничений требовалось создать игру, обладающую типичными признаками видеоигры: с визуализацией игрового мира, персонажей и четко определенным состоянием игры (например, локацией и инвентарём персонажа). Чтобы избежать проблем забывания контекста, было решено использовать подход function calling, при котором внутреннее состояние игры хранится отдельно, подобно конвенциональным видеоиграм. В этом случае LLM служит интерфейсом взаимодействия, преобразующим текстовые запросы пользователя в вызовы строго заданных функций API игрового движка.

В рамках работы был разработан прототип ролевой игры с использованием fine-tuned языковой модели gemma-2-9b-it-russian-function-calling-GGUF и подхода function calling. Была реализована архитектура, позволяющая преобразовывать произвольные текстовые запросы игрока в конкретные вызовы функций API самописного игрового движка на основе библиотеки pygame. Такой подход позволил обеспечить управляемость и целостность игрового состояния, сохранив при этом все преимущества интерактивности и гибкости, которые предоставляет интеграция LLM в игровой процесс.
\section*{Ключевые слова}
Large Language Model, Function Calling, Видеоигры, Ролевая игра, Pygame
\newpage
% \newpage
\section{Введение}
С момента зарождения ролевых игр разработчики стремились к максимальному оживлению игрового мира и персонажей (NPC). Создавались различные подходы к реализации диалоговых систем, включая попытки внедрения свободных, нелинейных диалогов. Одним из примеров может служить система диалогов в игре Morrowind, где игроку предоставлялся по сути словарь доступных тем для обсуждения, что создавало ощущение более живого и гибкого общения. Помимо этого, разработчики стремились предоставить игрокам максимальную свободу действий, приближая игровой опыт к формату настольных ролевых игр, таких как Dungeons \& Dragons\cite{dandd}, где игрок может напрямую сообщить ведущему любое действие без необходимости выбирать его из ограниченного списка. Появление LLM породило у разработчиков надежду на решение многолетней проблемы создания по-настоящему живых, осмысленных NPC, способных поддерживать диалог практически на любые темы и динамически реагировать на действия игрока.

Современные достижения в области больших языковых моделей (LLM, Large Language Models) открывают значительные перспективы для разработки интерактивных приложений и компьютерных игр. Эти модели, такие как GPT, LLaMA и их производные, продемонстрировали способность генерировать связные, осмысленные тексты, эффективно обрабатывать запросы пользователей и имитировать живое человеческое общение. В связи с этим разработчики игр проявляют повышенный интерес к интеграции подобных решений в игровые системы, языковые модели стали восприниматься как потенциальное универсальное средство, способное радикально преобразить взаимодействие с игровым миром.

Одним из наиболее известных примеров применения LLM в игровой сфере стала игра AI Dungeon. Несмотря на новаторский подход и популярность среди пользователей, AI Dungeon представляет собой преимущественно текстовый квест, в котором языковая модель взаимодействует с пользователем в режиме чата с минимальными ограничениями и практически без дополнительного контроля игрового контекста. Это ведет к тому, что игровой процесс зачастую становится несфокусированным: пользователи свободно отклоняются от сюжетной линии, а модель легко переключается на темы, не имеющие отношения к игре.

Подобные ограничения существенно снижают потенциал применения LLM в более традиционных компьютерных играх с четко заданным состоянием и визуальным представлением. Игры, реализованные с помощью LLM «в лоб», лишены четкой игровой структуры и не способны надежно поддерживать важные параметры, такие как положение персонажа на карте, состояние инвентаря или текущие задания.

Таким образом, возникает задача создания архитектуры интеграции языковых моделей в игры, которая позволяет сохранять все преимущества гибкости и реалистичности взаимодействия с LLM, но при этом обеспечивает строгий контроль и четкое управление игровым состоянием. Для этого в данной работе предлагается использовать подход function calling, предполагающий вынесение игрового состояния и логики в отдельную структуру, управляемую конкретными функциями, которые языковая модель может вызывать по мере необходимости. В этом случае модель служит посредником между игроком и игровым движком, преобразуя текстовые команды пользователя в формализованные вызовы API игры.

Целью данной работы является разработка и экспериментальная проверка подобной архитектуры на примере ролевой игры с самописным движком на базе библиотеки pygame и специально дообученной языковой моделью. Движок включает в себя бесконечный процедурно-генерируемым клеточный мир, локации, персонажи, имеющие личный граф отношений и динамическую генерации заданий (квестов) на основе этого графа.

Так же в рамках этой работы были протестированы некоторые другие модели, так же дообученные и не дообученные под function calling.

\section{Обзор проблемы и существующих решений}

\subsection{Специфика ролевых игр}

Ролевые игры (RPG) исторически представляют собой жанр, стремящийся к воссозданию максимально насыщенного, живого мира, в котором игроку предоставляется возможность действовать свободно и взаимодействовать с окружающей средой и персонажами на уровне, приближенном к реальной жизни. Основная идея RPG заключается не только в прохождении заранее заданных сюжетных квестов, но и в переживании роли — вживания в персонажа, исследовании мира, принятию решений, влияющих на дальнейшее развитие событий.

Для достижения эффекта глубокой иммерсивности разработчики ролевых игр тратят значительные ресурсы на создание так называемого ``lore'' — внутренней мифологии, истории и структуры мира. Это включает описание географии, фракций, рас, политических систем, а также проработку взаимоотношений между персонажами и обществами. Такая детализация позволяет не только насытить игру контентом, но и придать правдоподобие всему происходящему.

Одной из характерных особенностей RPG является наличие многочисленных неигровых персонажей (NPC), каждый из которых может обладать уникальной историей, мотивацией и набором диалогов. Чтобы обеспечить взаимодействие с NPC, разработчики создают разветвлённые диалоговые ветки, часто с множеством ответвлений и развилок, зависящих от предыдущего выбора игрока. Проработка диалогов требует как креативного, так и системного подхода — часто используются специальные редакторы, сценарные деревья и системы тегов. В современных RPG число NPC может исчисляться сотнями, а количество возможных диалогов — тысячами строк.

Кроме проработки сюжета и диалогов, особое внимание уделяется расширению геймплейных механик. В типичной ролевой игре пользователь может исследовать открытый мир, собирать ресурсы, выполнять задания, прокачивать персонажа, участвовать в боях и торговле, а также взаимодействовать с элементами окружения. Все эти механики служат не самоцели, а подкреплению главной идеи — иллюзии свободы выбора и симуляции ``жизни'' в вымышленной вселенной.

Таким образом, специфика ролевых игр требует не просто реализации игрового процесса, а создания комплексной системы, способной обеспечить вариативность, глубину и отклик на действия игрока. Это делает RPG идеальной платформой для интеграции языковых моделей, способных генерировать диалоги, описания и поведение персонажей на лету, особенно при возможности вызова моделью внутриигровых функций.


\subsection{Использование LLM в компьютерных играх}

Интеграция больших языковых моделей (LLM) в игровые проекты стала активной областью исследований и разработок с появлением моделей, способных поддерживать связный диалог, интерпретировать намерения пользователя и генерировать текст в реальном времени. Наиболее распространённым сценарием использования LLM является создание интерактивных текстовых приключений и систем общения с неигровыми персонажами (NPC).

Одним из первых проектов, реализовавших идею использования LLM в игровой среде, стал AI Dungeon, основанный изначально на GPT-2, а затем обновлённый до GPT-3. Игра представляет собой текстовое приключение, в котором игрок взаимодействует с миром путём ввода произвольных команд, а модель отвечает в виде продолжения истории. Такой формат обеспечил высокую степень свободы и непредсказуемости в игровом процессе, что сделало проект популярным среди энтузиастов интерактивного повествования.

Другие примеры включают эксперименты с NPC-ботами в ролевых играх (например, модификация Mantella\cite{mantella} для Skyrim\cite{skyrim} и Fallout 4 или Morrowind\cite{morrowind}), где LLM используются для генерации диалогов на лету. Кроме того, фреймворки вроде Inworld.ai, Convai и Charisma.ai предлагают разработчикам инструменты для создания LLM-агентов, которые можно внедрить в игровые или VR-сцены.

\subsection{Проблемы текущих подходов}

Несмотря на впечатляющие возможности, прямое использование LLM в играх сталкивается с рядом проблем. В первую очередь, языковая модель по своей природе не имеет «памяти» вне текущего диалога и не может надёжно отслеживать состояние мира. В AI Dungeon, к примеру, все параметры игрового состояния --- текущее местоположение, инвентарь, цели игрока --- хранятся лишь в виде текста и подвержены искажениям, забыванию или противоречиям. Это снижает предсказуемость поведения системы и делает невозможным реализацию сложной игровой логики.

Кроме того, из-за отсутствия структурированного API такие системы склонны к генерации нерелевантного текста. Игроки могут использовать систему как универсального чат-бота, отклоняясь от игровой цели. Модель может выступать в роли психолога, советчика, философа или собеседника по бытовым вопросам, что разрушает ощущение целостного игрового опыта.

Попытки ограничить поведение модели шаблонами или жёстко заданными подсказками лишь частично решают проблему, но снижают гибкость взаимодействия. Также остаются вопросы производительности и стоимости, особенно при использовании облачных моделей.

\subsection{Механизм Function Calling и его применение в системах с LLM}

Для преодоления перечисленных проблем существует механизм Function Calling --- способ взаимодействия, при котором языковая модель не просто генерирует текст, а формирует структурированный запрос на вызов одной из заранее определённых функций.

Термин "function calling" в контексте LLM стал широко известен после обновления OpenAI API в июне 2023 года, когда была добавлена поддержка передачи модели списка доступных функций и получения от неё строго структурированного JSON-ответа с названием функции и аргументами. Это стало важным шагом, теперь можно было встраивать LLM в реальные системы, как «умный маршрутизатор» команд. Подход Function Calling получил реализацию в фреймворках LangChain и Semantic Kernel.

В контексте компьютерных игр function calling позволяет вынести логику игры за пределы модели. Языковая модель интерпретирует запрос пользователя и возвращает JSON с именем функции и аргументами. Например, вот ответ модели для вызова функции перемещения персонажа из данной работы:

\begin{verbatim}
{
    "name": "go_to",
    "arguments": {
        "location": "town"
    }
}
\end{verbatim}

На основе такого формата игра может надёжно обработать команду, изменить состояние, визуализировать изменения и сохранить прогресс. В то же время, модель сохраняет роль гибкого интерфейса, способного понимать естественный язык, что даёт игроку свободу отыгрывания персонажа и увеличивает иммерсивность.

\newpage
\section{Структура игрового движка}

Для реализации данной работы был разработан игровой движок, построенный на базе библиотеки \texttt{Pygame}. Движок минималистичен и расширяем с точки зрения контента, о чём описано ниже. В задачи движка входит поддержка состояния игрового мира, обработка ввода пользователя и визуализация текущего состояния, включая карту и действия игрока.

\subsection{Игровой мир и его генерация}
    
Игровой мир реализован в классе \texttt{World} и представляет из себя бесконечное двумерное поле из тайлов, объединённых в чанки размером 32×32. Тайлы уникальны по нескольким свойствам, среди которых: текстура, проходимость (например, персонаж не может двигаться по воде), скорость перемещения по тайлу. Набор тайлов и их свойства не являются частью движка, а могут быть гибко настроены через систему описания контента, которая будет описана ниже.

Генерация карты реализована процедурно, то есть в каждый момент времени генерируется только чанк занимаемый игроком и окружающие его, если они не были сгенерированы ранее. Так поддерживается возможность потенциально бесконечного по размеру мира при ограниченной памяти компьютера.

Генератор использует шум Перлина (Perlin Noise)\cite{perlin}. В зависимости от значений шума каждому тайлу присваивается высота и влажность, на основе которых выбирается тип поверхности. Диапазоны высоты и влажности, при которых может быть выбран конкретный тайл указывается в его свойствах.

Каждый тайл на карте может содержать объект, который может быть либо декоративным (и блокировать или не блокировать путь), а может являться неким «порталом» в другую локацию -- так реализованы вложенные локации, в которые может перемещаться игрок. Внутренние локации так же представляют из себя тайловые карты, однако они не являются бесконечными.

Как пример: на глобальной карте может быть тайл с объектом «город», который является «интерьером», т.е. внутренней локацией. Глобальная карта в такой ситуации является «экстерьером».

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{kirkwall.png}
    \caption{Бесконечный мир, персонаж и город}
    \label{fig:mylabel}
\end{figure}

\item \textbf{Игрок и неигровые персонажи (NPC)}

Игрок и NPC объединены классом \texttt{Character}, который который инкапсулирует логику перемещения и взаимодействия, состояние здоровья. Каждый персонаж имеет некоторое положение в мире или на конкретной локации и может свободно перемещаться по доступным тайлам, а также между экстерьерами и интерьерами.

Пути для перемещения персонажей в рамках одной локации вычисляются алгоритмом A* (A star)\cite{astar} для поиска оптимального пути. Игрок при запросе на перемещение так же использует этот же алгоритм.

Игрок и NPC имеют личный инвентарь и могут манипулировать предметами в нём (передать другому персонажу, выбросить). Предметы инвентаря могут являться частью квестов.

Персонажи так же могут вступать в бой друг против друга, используя какое-либо оружие из инвентаря.

\subsection{Граф отношений NPC и генерация квестов}

Каждый NPC в игре включён в граф отношений, реализованный на уровне логики генерации квестов. Рёбра графа обозначают связи между персонажами (дружба, вражда, родство и пр.), а вершины — конкретные NPC. Это позволяет строить квесты динамически: например, один персонаж может просить игрока помочь другому, или отомстить за нападение.

Такая система задаёт контекст для общения с NPC и служит источником заданий, адаптированных к текущей ситуации в мире. Это даёт игроку уникальный опыт в каждой игровой сессии.

\subsection{Интерфейс пользователя}

Элементы интерфейса в игре реализованы с помощью вспомогательной библиотеки \texttt{pygame\_gui} и в основном представлены меню выбора мира и текстовым полем для ввода команд (промптов) игроком. Это поле обрабатывает текстовые команды, которые затем передаются в языковую модель для интерпретации и трансформации в вызовы игровых функций (function calling).

\subsection{LLM}

Центральным компонентом движка игры является LLM, в которую передаётся запрос пользователя для матчинга с наиболее подходящей внутриигровой функцией.

Так как не все модели имеют в шаблоне своего токенизатора встроенную поддержку аргумента \texttt{tools} метода \texttt{apply\_chat\_template}, был написан собственный Jinja2 макрос и шаблон для вставки в системный промпт. Шаблон и используемый в нём макрос представлены в приложении. Сам системный промпт без функций выглядит так:

\texttt{Ты - полезный помощник, помогающий выбрать необходимую функцию для вызова. Всегда отвечай только валидным JSON, не добавляй пояснений, текста или комментариев — только чистый JSON. Формат JSON для указания функции и аргументов: \{"name": function\_name, "arguments": \{"some\_argument": "some\_value"\}\}. Вот доступные тебе функции, используй их при необходимости - ...}.

\subsection{Граф отношений NPC и генерация квестов}

Каждый NPC в игре включён в граф отношений, реализованный на уровне логики генерации квестов. Рёбра графа обозначают связи между персонажами (дружба, вражда, родство и пр.), а вершины — конкретные NPC. Это позволяет строить квесты динамически: например, один персонаж может просить игрока принести предмет другому, или отомстить за нападение.

Такая система задаёт контекст для отношения NPC к игроку и служит источником заданий, адаптированных к текущей ситуации в игровом мире.

\subsection{Система описания контента через YAML-файлы}

Каждый тайл, вид объекта или NPC в игре описан в отдельном YAML-файле, содержащем его свойства. Например для тайлов это проходимость, допустимая высота и температура. Так же для любого объекта может быть указана альтернативная текстура, если её не нашлось по названию файла.

Такая модульность в описании контента позволяет легко модифицировать игру без необходимости переписывать движое. При старте игры все YAML-файлы считываются и превращаются в хранятся в классе \texttt{Content}.

\item \textbf{Игровой цикл}

Центральной частью движка является основной цикл, в котором обрабатываются события (ввод из текстового поля), обновляется состояние игрока и интерфейса, и выполняется отрисовка карты, интерфейса. Частота обновления ограничена 60 кадрами в секунду.

\subsection{Список доступных функций}
В рамках игрового движка предусмотрен набор функций, которые могут быть вызваны с помощью языковой модели. Каждая функция оформлена в формате API-вызова и принимает один или несколько аргументов. Ниже представлены доступные функции и их описание.

\subsubsection{Функция \texttt{go\_to}}

\textbf{Назначение:} Перемещение персонажа в заданную локацию.

\textbf{Аргументы:}
\begin{itemize}
    \item \texttt{location (str)} --- обязательное. Название локации, куда следует направиться.
\end{itemize}

\textbf{Замечания:} Аргумент \texttt{location} не может быть опущен. При его отсутствии вызов считается некорректным.

\subsubsection{Функция \texttt{move}}

\textbf{Назначение:} Начало движения в указанную сторону.

\textbf{Аргументы:}
\begin{itemize}
    \item \texttt{side (str)} --- обязательное. Направление движения: \texttt{north}, \texttt{east}, \texttt{south}, \texttt{west}.
\end{itemize}

\textbf{Замечания:} При отсутствии аргумента \texttt{side} функция не может быть выполнена.

\subsubsection{Функция \texttt{stop}}

\textbf{Назначение:} Остановка текущего действия.

\textbf{Аргументы:} отсутствуют.

\subsubsection{Функция \texttt{go\_inside}}

\textbf{Назначение:} Войти в здание или сооружение.

\textbf{Аргументы:}
\begin{itemize}
    \item \texttt{location (str)} --- необязательное. Название локации, куда следует войти.
\end{itemize}

\textbf{Поведение по умолчанию:} Если аргумент не указан, персонаж входит в ближайшую доступную локацию.

\subsubsection{Функция \texttt{take\_quest}}

\textbf{Назначение:} Получение квеста у NPC.

\textbf{Аргументы:}
\begin{itemize}
    \item \texttt{npc (str)} --- необязательное. Имя NPC, у которого нужно взять задание.
\end{itemize}

\textbf{Поведение по умолчанию:} Если аргумент не указан, квест берётся у ближайшего NPC.

\subsubsection{Функция \texttt{fight}}

\textbf{Назначение:} Начать бой с NPC.

\textbf{Аргументы:}
\begin{itemize}
    \item \texttt{npc (str)} --- необязательное. Имя NPC, с которым нужно начать бой.
\end{itemize}

\textbf{Поведение по умолчанию:} Если имя не указано, бой начинается с ближайшим NPC.

\subsubsection{Функция \texttt{give}}

\textbf{Назначение:} Передача предмета NPC.

\textbf{Аргументы:}
\begin{itemize}
    \item \texttt{item (str)} --- обязательное. Название передаваемого предмета.
    \item \texttt{amount (int)} --- необязательное. Количество предметов. По умолчанию 1.
    \item \texttt{npc (str)} --- необязательное. Имя NPC, которому передаётся предмет.
\end{itemize}

\textbf{Поведение по умолчанию:} Если не указано количество, передаётся один предмет; если не указан NPC, предмет отдается ближайшему.

\subsubsection{Функция \texttt{drop}}

\textbf{Назначение:} Выбросить предмет из инвентаря.

\textbf{Аргументы:}
\begin{itemize}
    \item \texttt{item (str)} --- обязательное. Название выбрасываемого предмета.
    \item \texttt{amount (int)} --- необязательное. Количество. По умолчанию 1.
\end{itemize}

\textbf{Поведение по умолчанию:} Если количество не указано, выбрасывается один предмет.

\subsection{Сохранение мира}

Игровой мир сохраняется в базе данных SQLite, что позволяет переносить его между устройствами и использовать в качестве формата обмена. Объекты и NPC хранятся в отдельных таблицах. Чанки мира хранятся как плоские вектора в бинарном виде.

\subsection{Связь с языковой моделью и function calling}

Для обработки команд используется языковая модель, дообученная на задачи function calling (о выбранной модели смотри раздел Результаты). Она получает текстовую команду игрока (например, \enquote{поговори с Арагорном}) и на выходе выдаёт JSON с именем функции и аргументами:

\begin{verbatim}
{
    "name": "talk",
    "arguments": {
        "npc": "Арагорн"
    }
}
\end{verbatim}

Модель использует шаблон диалога с явным указанием доступных функций, описанный ранее и требует строгий формат вывода. Это позволяет избежать произвольных ответов и обеспечивает точную интеграцию с игровым API.

Функции, доступные для вызова, описываются в словаре \texttt{FUNCTIONS}, преобразуются в json-описания и передаются в модель в аргументе \texttt{tools}. При получении результата от модели происходит проверка корректности аргументов и вызов соответствующего метода на стороне движка.


\section{Метрики оценки качества}
В данном разделе описаны выбранные метрики, направленные на поэтапную проверку корректности поведения модели. Особенность задачи заключается не только в генерации текстового ответа, но и в необходимости правильно определить, когда следует использовать функцию, а затем корректно сформировать её вызов.

Были выделены следующие ключевые метрики:

\begin{enumerate}
\item \textbf{Факт вызова функции}% (Function Call Detection)}

Данная бинарная метрика фиксирует сам факт того, что модель вернула функцию (в виде JSON), независимо от корректности её содержания или уместности вызова.

Результат считается положительным, если модель выдала JSON-объект, описывающий вызов функции.

Отрицательным — если модель не вернула вызов функции.

Эта метрика используется как вспомогательная: она позволяет вычислить общую чувствительность модели к необходимости действий и служит основой для подсчёта точности и полноты (precision/recall) при построении сводных таблиц.

\item \textbf{Уместность вызова функции}% (Function Call Appropriateness)}

Эта метрика оценивает, правильно ли модель определила необходимость вызова функции.

Если модель корректно вызвала функцию в ситуации, где это требовалось, либо воздержалась от вызова в неподходящей ситуации — результат считается положительным.

Если модель вызвала функцию там, где это было не нужно, либо проигнорировала необходимость вызова — результат считается ошибочным.

Это базовая метрика, определяющая способность модели понимать контекст общения и принимать решение о переходе к API-вызову.

\item \textbf{Корректность функции и аргументов}

Вспомогательные метрики. Оценивают, правильно ли модель определила необходимую функцию и аргументы соответственно.

\item \textbf{Корректность вызова}% (Function Call Accuracy)}

Наиболее строгая метрика, оценивающая, насколько точно модель сформировала сам вызов:

Сравнивается имя сгенерированной функции с ожидаемым.
Проверяются значения аргументов, включая соответствие по именам и типам.

Результат положительный, если полностью совпадают как имя функции, так и все аргументы.

Эта метрика отражает способность модели не только распознать контекст, требующий действия, но и правильно подготовить структурированный вызов.
\end{enumerate}

\section{Результаты}
Для проведения экспериментов и подсчета метрик было выбрано несколько моделей:
\begin{enumerate}
\item \textbf{gemma-2-9b-it-russian-function-calling-GGUF}

gemma-2-9b-it-russian-function-calling-GGUF — это специализированная версия модели google/gemma-2-9b-it, дообученная для задачи function calling на реальных пользовательских данных на русском языке. В отличие от многих других моделей, обучение проводилось исключительно на размеченных вручную данных, без использования синтетических генераций.

\item \textbf{Vikhr-Nemo}

Vikhr-Nemo — это флагманская унимодальная большая языковая модель (LLM), разработанная командой VikhrModels. Является улучшенной версией модели Mistralai/Mistral-Nemo-Instruct-2407 и специально адаптирована для работы на русском и английском языках.

\item \textbf{openchat/openchat-3.5-0106}

openchat-3.5-0106 — это открытая языковая модель, вдохновлённая архитектурой и поведением GPT-3.5. Она разработана сообществом OpenChat и позиционируется как инструктивно дообученная LLM, способная вести диалог, генерировать код, выполнять суммаризацию и решать задачи на логическое мышление.

Модель обучалась на многоязычном корпусе, включая английский и частично русский языки, и предназначена для использования в задачах, требующих генерации последовательного и контекстуально релевантного текста.
\end{enumerate}
Ниже представлены полученные метрики для каждой из рассмотренных моделей:
\begin{table}[htbp]
\centering
\caption{Процент успеха по каждой метрике для трёх моделей}
\label{tab:model_metrics_comparison}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Метрика} & \textbf{Gemma} & \textbf{Openchat} & \textbf{Vikhr} \\
\hline
Функция вызвана & 96.55 \% & 22.73 \% & 91.30 \% \\
\hline
Ложно позитивно & 20.69 \% & 50.36 \% & 28.45 \% \\
\hline
Ложно негативно & 0.00 \% & 65.62 \% & 5.71 \% \\
\hline
Функция корректна & 72.41 \% & 10.35 \% & 64.52 \% \\
\hline
Аргументы корректны & 62.07 \% & 8.03 \% & 56.61 \% \\
\hline
Полное совпадение & 62.07 \% & 5.06 \% & 51.60 \% \\
\hline
\end{tabular}
\end{table}

Как видно из таблицы, наиболее подходящей для игры моделью является \texttt{DiTy/gemma-2-9b-it-russian-function-calling-GGUF}. Она и была выбрана.

\section{Приложение А. Макрос \texttt{render\_json} для шаблона \texttt{tools}}
\begin{verbatim}
{%- macro render_json(d, indent=4) -%}
{%- if d is string %}
    {{ '"' + d + '"' }}
{%- elif d is mapping %}
    {%- for key, value in d.items() %}
        {%- if value is string %}
{{ " " * indent }}{{ '"' + key + '": "' + value + '"' }}
        {%- elif value is mapping %}
{{ " " * indent }}{{ '"' + key + '": {' }}
{{ render_json(value, indent + 4) }}
{{ " " * indent }}}
        {%- elif value is sequence %}
{{ " " * indent }}{{ '"' + key + '": [' }}
            {%- for item in value %}
{{ " " * (indent + 4) }}{{ render_json(item, indent + 4) }}{% if not loop.last %},{% endif %}
            {%- endfor %}
{{ " " * indent }}]
        {%- else %}
{{ " " * indent }}{{ '"' + key + '": ' + value|string }}
        {%- endif %}
        {%- if not loop.last %},{% endif %}
    {%- endfor %}
{%- elif d is sequence %}
    {%- for item in d %}
{{ " " * indent }}{{ render_json(item, indent + 4) }}{% if not loop.last %},{% endif %}
    {%- endfor %}
{%- else %}
{{ " " * indent }}{{ d|string }}
{%- endif %}
{%- endmacro %}
\end{verbatim}
\section{Приложение Б. Шаблон \texttt{tools}}
\begin{verbatim}
{%- if tools is not none %}
    {%- for tool in tools %}
        {%- set tool = tool.function %}
        {{- '{
' }}
        {{- render_json(tool, 4) }}
        {%- if not loop.last %}
            {{- "
},
" }}
        {%- else %}
            {{- "
}
" }}
        {% endif %}
    {%- endfor %}
    {%- elif system_message != "" %}
        {{- '

' }}
{%- endif %}
\end{verbatim}
\newpage
\newpage

\begin{thebibliography}{9}
\bibitem{dandd}
Chris Callison-Burch, Gaurav Singh Tomar, Lara J. Martin, Daphne Ippolito, Suma Bailis, David Reitter. 2022. \emph{\href{https://arxiv.org/abs/2210.07109}{Dungeons and Dragons as a Dialog Challenge for Artificial Intelligence}}.
\bibitem{astar}
Hart, Peter E. and Nilsson, Nils J. and Raphael, Bertram. 1968. \emph{\href{https://ieeexplore.ieee.org/document/4082128}{A Formal Basis for the Heuristic Determination of Minimum Cost Paths}}.
\bibitem{perlin}
Ken Perlin. 1985. \emph{\href{https://www.cs.drexel.edu/~deb39/Classes/Papers/p287-perlin.pdf}{An Image Synthesizer}}.
\bibitem{mantella}
«Art from the Machine».  2024. \href{https://art-from-the-machine.github.io/Mantella/index.html}{Mantella}
\bibitem{morrowind}
Автор канала «Ролеплей для души». 2025. \href{https://www.youtube.com/watch?v=fJZOXP69L6w&t=18s}{Мод для живого общения с NPC для Morrowind, использующий Gemini и ElevenLabs}
\bibitem{skyrim}
Manuel Guimarães, Pedro A. Santos, Arnav Jhala. 2022. \emph{\href{https://arxiv.org/abs/2207.13398}{Emergent social NPC interactions in the Social NPCs Skyrim mod and beyond}}.
\bibitem{dialogue}
Li Song. 2025. \emph{\href{https://arxiv.org/html/2504.13928v1}{LLM-Driven NPCs: Cross-Platform Dialogue System for Games and Social Platforms}}.
\end{thebibliography}

\end{document}
